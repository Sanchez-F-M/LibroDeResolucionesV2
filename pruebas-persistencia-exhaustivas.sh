#!/bin/bash

# Pruebas exhaustivas de persistencia de datos - Aplicaci√≥n Libro de Resoluciones
# filepath: c:\Users\flavi\OneDrive\Escritorio\LibroDeResolucionesV2\pruebas-persistencia-exhaustivas.sh

echo "üî¨ PRUEBAS EXHAUSTIVAS DE PERSISTENCIA - LIBRO DE RESOLUCIONES"
echo "============================================================="
echo ""

# Configuraci√≥n
BASE_URL="http://localhost:10000"
TEST_DIR="temp_persistencia_tests"
ADMIN_USER="admin"
ADMIN_PASS="admin123"
TEST_RESULTS_FILE="resultados_persistencia.log"

# Colores
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Contadores
TESTS_TOTAL=0
TESTS_PASSED=0
TESTS_FAILED=0
RESOLUTIONS_CREATED=0
IMAGES_UPLOADED=0

# Funciones de logging
log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
    echo "[$(date)] SUCCESS: $1" >> $TEST_RESULTS_FILE
    ((TESTS_PASSED++))
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
    echo "[$(date)] ERROR: $1" >> $TEST_RESULTS_FILE
    ((TESTS_FAILED++))
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
    echo "[$(date)] WARNING: $1" >> $TEST_RESULTS_FILE
}

log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
    echo "[$(date)] INFO: $1" >> $TEST_RESULTS_FILE
}

log_test() {
    echo -e "${PURPLE}üß™ $1${NC}"
    echo "[$(date)] TEST: $1" >> $TEST_RESULTS_FILE
    ((TESTS_TOTAL++))
}

# Funci√≥n para obtener token JWT
get_auth_token() {
    local response=$(curl -s -X POST "$BASE_URL/api/user/login" \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"$ADMIN_USER\",\"password\":\"$ADMIN_PASS\"}")
    
    echo "$response" | grep -o '"token":"[^"]*' | cut -d'"' -f4
}

# Funci√≥n para crear archivo de imagen de prueba
create_test_image() {
    local filename=$1
    local content=$2
    
    mkdir -p $TEST_DIR
    echo "$content" > "$TEST_DIR/$filename"
    echo "$(date)" >> "$TEST_DIR/$filename"
    echo "Test ID: $(uuidgen 2>/dev/null || echo $RANDOM$RANDOM)" >> "$TEST_DIR/$filename"
}

# Funci√≥n para crear resoluci√≥n con imagen
create_resolution_with_image() {
    local res_number=$1
    local subject=$2
    local reference=$3
    local image_file=$4
    local token=$5
    
    local response=$(curl -s -X POST "$BASE_URL/api/books" \
        -H "Authorization: Bearer $token" \
        -F "NumdeResolucion=$res_number" \
        -F "Asunto=$subject" \
        -F "Referencia=$reference" \
        -F "FechaCreacion=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")" \
        -F "files=@$TEST_DIR/$image_file")
    
    echo "$response"
}

# Funci√≥n para obtener resoluci√≥n
get_resolution() {
    local res_number=$1
    local token=$2
    
    curl -s "$BASE_URL/api/books/$res_number" \
        -H "Authorization: Bearer $token"
}

# Funci√≥n para obtener todas las resoluciones
get_all_resolutions() {
    local token=$1
    
    curl -s "$BASE_URL/api/books/all" \
        -H "Authorization: Bearer $token"
}

# Funci√≥n para verificar servidor
check_server() {
    local health_response=$(curl -s "$BASE_URL/health" 2>/dev/null)
    
    if echo "$health_response" | grep -q "healthy"; then
        return 0
    else
        return 1
    fi
}

# Limpiar archivos anteriores
echo "üßπ Preparando entorno de pruebas..."
rm -rf $TEST_DIR 2>/dev/null
rm -f $TEST_RESULTS_FILE 2>/dev/null
mkdir -p $TEST_DIR

echo "[$(date)] INICIO DE PRUEBAS EXHAUSTIVAS DE PERSISTENCIA" > $TEST_RESULTS_FILE
echo "" >> $TEST_RESULTS_FILE

# ===========================================
# PRUEBA 1: VERIFICACI√ìN INICIAL DEL SERVIDOR
# ===========================================
log_test "PRUEBA 1: Verificaci√≥n inicial del servidor"

if check_server; then
    log_success "Servidor respondiendo correctamente"
    
    # Obtener informaci√≥n del servidor
    SERVER_INFO=$(curl -s "$BASE_URL/health")
    log_info "Informaci√≥n del servidor: $(echo $SERVER_INFO | head -c 100)..."
else
    log_error "Servidor no est√° respondiendo"
    echo ""
    echo "‚ùå PRUEBAS CANCELADAS: El servidor debe estar ejecut√°ndose"
    echo "üí° Para iniciar el servidor: cd server && npm run dev"
    exit 1
fi

echo ""

# ===========================================
# PRUEBA 2: AUTENTICACI√ìN Y TOKEN
# ===========================================
log_test "PRUEBA 2: Autenticaci√≥n y obtenci√≥n de token"

TOKEN=$(get_auth_token)

if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ]; then
    log_success "Token JWT obtenido correctamente"
    log_info "Token: ${TOKEN:0:20}..."
else
    log_error "No se pudo obtener token de autenticaci√≥n"
    echo ""
    echo "‚ùå PRUEBAS CANCELADAS: Problema de autenticaci√≥n"
    exit 1
fi

echo ""

# ===========================================
# PRUEBA 3: ESTADO INICIAL DE LA BASE DE DATOS
# ===========================================
log_test "PRUEBA 3: Estado inicial de la base de datos"

INITIAL_RESOLUTIONS=$(get_all_resolutions "$TOKEN")
INITIAL_COUNT=$(echo "$INITIAL_RESOLUTIONS" | jq '. | length' 2>/dev/null || echo "0")

log_info "Resoluciones existentes al inicio: $INITIAL_COUNT"
echo "Estado inicial de BD:" >> $TEST_RESULTS_FILE
echo "$INITIAL_RESOLUTIONS" >> $TEST_RESULTS_FILE
echo "" >> $TEST_RESULTS_FILE

echo ""

# ===========================================
# PRUEBA 4: CREAR M√öLTIPLES RESOLUCIONES
# ===========================================
log_test "PRUEBA 4: Creaci√≥n de m√∫ltiples resoluciones con im√°genes"

# Crear 5 resoluciones de prueba
for i in {1..5}; do
    timestamp=$(date +%s)
    res_number="PERSIST-TEST-$i-$timestamp"
    subject="Prueba de persistencia $i - $timestamp"
    reference="REF-PERSIST-$i-$timestamp"
    image_file="imagen-test-$i-$timestamp.txt"
    
    # Crear imagen de prueba
    create_test_image "$image_file" "IMAGEN DE PRUEBA $i PARA PERSISTENCIA - $timestamp"
    
    log_info "Creando resoluci√≥n $i: $res_number"
    
    # Crear resoluci√≥n
    create_response=$(create_resolution_with_image "$res_number" "$subject" "$reference" "$image_file" "$TOKEN")
    
    if echo "$create_response" | grep -q "exitosamente"; then
        log_success "Resoluci√≥n $i creada exitosamente"
        ((RESOLUTIONS_CREATED++))
        ((IMAGES_UPLOADED++))
        
        # Verificar inmediatamente que se puede recuperar
        sleep 1
        get_response=$(get_resolution "$res_number" "$TOKEN")
        
        if echo "$get_response" | grep -q "$res_number"; then
            log_success "Resoluci√≥n $i verificada - se puede recuperar inmediatamente"
        else
            log_error "Resoluci√≥n $i NO se puede recuperar inmediatamente"
        fi
    else
        log_error "Error al crear resoluci√≥n $i: $create_response"
    fi
    
    # Peque√±a pausa entre creaciones
    sleep 2
done

echo ""
log_info "Resoluciones creadas en esta sesi√≥n: $RESOLUTIONS_CREATED"
log_info "Im√°genes subidas en esta sesi√≥n: $IMAGES_UPLOADED"

echo ""

# ===========================================
# PRUEBA 5: VERIFICAR PERSISTENCIA INMEDIATA
# ===========================================
log_test "PRUEBA 5: Verificaci√≥n de persistencia inmediata"

# Obtener todas las resoluciones despu√©s de las creaciones
AFTER_CREATE_RESOLUTIONS=$(get_all_resolutions "$TOKEN")
AFTER_CREATE_COUNT=$(echo "$AFTER_CREATE_RESOLUTIONS" | jq '. | length' 2>/dev/null || echo "0")

log_info "Resoluciones despu√©s de crear: $AFTER_CREATE_COUNT"
log_info "Incremento esperado: $RESOLUTIONS_CREATED"

if [ $AFTER_CREATE_COUNT -ge $((INITIAL_COUNT + RESOLUTIONS_CREATED)) ]; then
    log_success "Todas las resoluciones persisten correctamente en BD"
else
    log_error "Algunas resoluciones NO persisten - esperado: $((INITIAL_COUNT + RESOLUTIONS_CREATED)), actual: $AFTER_CREATE_COUNT"
fi

echo ""

# ===========================================
# PRUEBA 6: VERIFICAR IM√ÅGENES INDIVIDUALES
# ===========================================
log_test "PRUEBA 6: Verificaci√≥n individual de im√°genes"

# Buscar las resoluciones creadas en esta sesi√≥n
CREATED_RESOLUTIONS=$(echo "$AFTER_CREATE_RESOLUTIONS" | jq -r '.[] | select(.NumdeResolucion | startswith("PERSIST-TEST-")) | .NumdeResolucion' 2>/dev/null)

if [ -n "$CREATED_RESOLUTIONS" ]; then
    echo "$CREATED_RESOLUTIONS" | while read -r resolution_number; do
        if [ -n "$resolution_number" ]; then
            log_info "Verificando resoluci√≥n: $resolution_number"
            
            resolution_data=$(get_resolution "$resolution_number" "$TOKEN")
            
            # Verificar que tiene im√°genes
            images_count=$(echo "$resolution_data" | jq -r '.[0].images | length' 2>/dev/null || echo "0")
            
            if [ "$images_count" -gt 0 ]; then
                log_success "Resoluci√≥n $resolution_number tiene $images_count imagen(es)"
                
                # Verificar URLs de im√°genes
                image_urls=$(echo "$resolution_data" | jq -r '.[0].images[]' 2>/dev/null)
                echo "$image_urls" | while read -r image_url; do
                    if [ -n "$image_url" ]; then
                        log_info "URL de imagen: $image_url"
                        
                        # Verificar si es URL de Cloudinary o local
                        if echo "$image_url" | grep -q "cloudinary.com"; then
                            log_success "Imagen almacenada en Cloudinary (persistente)"
                        elif echo "$image_url" | grep -q "uploads"; then
                            log_warning "Imagen almacenada localmente (no persistente en Render)"
                        else
                            log_warning "Formato de URL no reconocido: $image_url"
                        fi
                    fi
                done
            else
                log_error "Resoluci√≥n $resolution_number NO tiene im√°genes"
            fi
        fi
    done
else
    log_warning "No se encontraron resoluciones creadas en esta sesi√≥n"
fi

echo ""

# ===========================================
# PRUEBA 7: SIMULAR REINICIO (TEST DE MEMORIA)
# ===========================================
log_test "PRUEBA 7: Simulaci√≥n de reinicio - Test de memoria vs persistencia"

log_info "Esperando 5 segundos para simular paso del tiempo..."
sleep 5

# Obtener nuevo token (simula nueva sesi√≥n)
NEW_TOKEN=$(get_auth_token)

if [ -n "$NEW_TOKEN" ] && [ "$NEW_TOKEN" != "null" ]; then
    log_success "Nuevo token obtenido (simula nueva sesi√≥n)"
    
    # Verificar que todas las resoluciones siguen ah√≠
    AFTER_RESTART_RESOLUTIONS=$(get_all_resolutions "$NEW_TOKEN")
    AFTER_RESTART_COUNT=$(echo "$AFTER_RESTART_RESOLUTIONS" | jq '. | length' 2>/dev/null || echo "0")
    
    log_info "Resoluciones despu√©s de 'reinicio': $AFTER_RESTART_COUNT"
    
    if [ $AFTER_RESTART_COUNT -eq $AFTER_CREATE_COUNT ]; then
        log_success "PERSISTENCIA VERIFICADA: Todas las resoluciones sobreviven al reinicio simulado"
    else
        log_error "PROBLEMA DE PERSISTENCIA: Se perdieron datos despu√©s del reinicio simulado"
    fi
else
    log_error "No se pudo obtener nuevo token despu√©s del reinicio simulado"
fi

echo ""

# ===========================================
# PRUEBA 8: PRUEBA DE CARGA (M√öLTIPLES OPERACIONES)
# ===========================================
log_test "PRUEBA 8: Prueba de carga - Operaciones concurrentes"

log_info "Creando 3 resoluciones adicionales r√°pidamente..."

for i in {6..8}; do
    timestamp=$(date +%s)
    res_number="LOAD-TEST-$i-$timestamp"
    subject="Prueba de carga $i - $timestamp"
    reference="REF-LOAD-$i-$timestamp"
    image_file="imagen-load-$i-$timestamp.txt"
    
    create_test_image "$image_file" "IMAGEN DE CARGA $i - $timestamp"
    
    # Crear resoluci√≥n sin esperar
    create_response=$(create_resolution_with_image "$res_number" "$subject" "$reference" "$image_file" "$NEW_TOKEN")
    
    if echo "$create_response" | grep -q "exitosamente"; then
        log_success "Resoluci√≥n de carga $i creada"
        ((RESOLUTIONS_CREATED++))
    else
        log_error "Error en resoluci√≥n de carga $i"
    fi
done

echo ""

# ===========================================
# PRUEBA 9: VERIFICACI√ìN FINAL DE CONSISTENCIA
# ===========================================
log_test "PRUEBA 9: Verificaci√≥n final de consistencia de datos"

FINAL_RESOLUTIONS=$(get_all_resolutions "$NEW_TOKEN")
FINAL_COUNT=$(echo "$FINAL_RESOLUTIONS" | jq '. | length' 2>/dev/null || echo "0")

log_info "Conteo final de resoluciones: $FINAL_COUNT"
log_info "Resoluciones creadas en total: $RESOLUTIONS_CREATED"
log_info "Conteo inicial: $INITIAL_COUNT"
log_info "Esperado final: $((INITIAL_COUNT + RESOLUTIONS_CREATED))"

if [ $FINAL_COUNT -eq $((INITIAL_COUNT + RESOLUTIONS_CREATED)) ]; then
    log_success "CONSISTENCIA PERFECTA: Todos los datos est√°n presentes"
else
    difference=$((FINAL_COUNT - INITIAL_COUNT))
    log_warning "INCONSISTENCIA: Esperado $RESOLUTIONS_CREATED, encontrado $difference nuevas resoluciones"
fi

# Verificar que no hay duplicados
DUPLICATE_CHECK=$(echo "$FINAL_RESOLUTIONS" | jq -r '.[].NumdeResolucion' | sort | uniq -d 2>/dev/null)

if [ -z "$DUPLICATE_CHECK" ]; then
    log_success "No se encontraron duplicados - Integridad OK"
else
    log_error "Se encontraron duplicados: $DUPLICATE_CHECK"
fi

echo ""

# ===========================================
# PRUEBA 10: AN√ÅLISIS DE CONFIGURACI√ìN DE ALMACENAMIENTO
# ===========================================
log_test "PRUEBA 10: An√°lisis de configuraci√≥n de almacenamiento"

# Verificar configuraci√≥n de Cloudinary
if [ -f "server/.env" ]; then
    if grep -q "CLOUDINARY_CLOUD_NAME=" server/.env; then
        CLOUD_NAME=$(grep "CLOUDINARY_CLOUD_NAME=" server/.env | cut -d'=' -f2)
        if [ -n "$CLOUD_NAME" ] && [ "$CLOUD_NAME" != "" ]; then
            log_success "Cloudinary configurado (Cloud Name: $CLOUD_NAME)"
            log_info "PREDICCI√ìN: En producci√≥n usar√° Cloudinary (persistente)"
        else
            log_warning "Cloudinary definido pero vac√≠o - usando almacenamiento local"
            log_warning "PREDICCI√ìN: En producci√≥n podr√≠a perder im√°genes"
        fi
    else
        log_warning "Cloudinary no configurado - usando almacenamiento local"
        log_warning "PREDICCI√ìN: En producci√≥n perder√° im√°genes"
    fi
else
    log_error "Archivo .env no encontrado"
fi

# Verificar directorio uploads
if [ -d "server/uploads" ]; then
    upload_count=$(find server/uploads -type f 2>/dev/null | wc -l)
    log_info "Archivos en directorio uploads: $upload_count"
    
    if [ $upload_count -gt 0 ]; then
        log_warning "Usando almacenamiento local - archivos se perder√°n en Render"
    fi
else
    log_info "Directorio uploads no existe (posiblemente usando Cloudinary)"
fi

echo ""

# ===========================================
# REPORTE FINAL
# ===========================================
echo "üìä REPORTE FINAL DE PRUEBAS DE PERSISTENCIA"
echo "==========================================="
echo ""

# Calcular estad√≠sticas
TOTAL_EXPECTED=$((INITIAL_COUNT + RESOLUTIONS_CREATED))
SUCCESS_RATE=0

if [ $TESTS_TOTAL -gt 0 ]; then
    SUCCESS_RATE=$((TESTS_PASSED * 100 / TESTS_TOTAL))
fi

echo -e "${BLUE}üìà ESTAD√çSTICAS:${NC}"
echo "   ‚Ä¢ Total de pruebas ejecutadas: $TESTS_TOTAL"
echo "   ‚Ä¢ Pruebas exitosas: $TESTS_PASSED"
echo "   ‚Ä¢ Pruebas fallidas: $TESTS_FAILED"
echo "   ‚Ä¢ Tasa de √©xito: $SUCCESS_RATE%"
echo ""

echo -e "${BLUE}üìä DATOS:${NC}"
echo "   ‚Ä¢ Resoluciones iniciales: $INITIAL_COUNT"
echo "   ‚Ä¢ Resoluciones creadas: $RESOLUTIONS_CREATED"
echo "   ‚Ä¢ Im√°genes subidas: $IMAGES_UPLOADED"
echo "   ‚Ä¢ Total final: $FINAL_COUNT"
echo "   ‚Ä¢ Esperado: $TOTAL_EXPECTED"
echo ""

# Evaluaci√≥n final
echo -e "${BLUE}üéØ EVALUACI√ìN FINAL:${NC}"

if [ $FINAL_COUNT -eq $TOTAL_EXPECTED ] && [ $SUCCESS_RATE -ge 80 ]; then
    echo -e "${GREEN}‚úÖ PERSISTENCIA VERIFICADA EXITOSAMENTE${NC}"
    echo ""
    echo "   üèÜ Todos los datos persisten correctamente"
    echo "   üèÜ No hay p√©rdida de informaci√≥n"
    echo "   üèÜ Sistema funcionando como esperado"
    echo ""
    
    if grep -q "cloudinary.com" $TEST_RESULTS_FILE 2>/dev/null; then
        echo -e "${GREEN}   üå©Ô∏è  CLOUDINARY DETECTADO: Datos persistir√°n en producci√≥n${NC}"
    else
        echo -e "${YELLOW}   ‚ö†Ô∏è  ALMACENAMIENTO LOCAL: Configurar Cloudinary para producci√≥n${NC}"
    fi
    
elif [ $FINAL_COUNT -eq $TOTAL_EXPECTED ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  PERSISTENCIA PARCIAL${NC}"
    echo ""
    echo "   ‚úÖ Los datos persisten en esta sesi√≥n"
    echo "   ‚ö†Ô∏è  Algunas pruebas tuvieron advertencias"
    echo "   üí° Revisar configuraci√≥n de almacenamiento"
    
else
    echo -e "${RED}‚ùå PROBLEMA DE PERSISTENCIA DETECTADO${NC}"
    echo ""
    echo "   ‚ùå Se perdieron datos durante las pruebas"
    echo "   ‚ùå Diferencia: esperado $TOTAL_EXPECTED, actual $FINAL_COUNT"
    echo "   üîß Requiere investigaci√≥n adicional"
fi

echo ""

# Recomendaciones
echo -e "${BLUE}üìã RECOMENDACIONES:${NC}"

if grep -q "CLOUDINARY_CLOUD_NAME=" server/.env && grep -q "CLOUDINARY_API_KEY=" server/.env; then
    CLOUD_NAME=$(grep "CLOUDINARY_CLOUD_NAME=" server/.env | cut -d'=' -f2)
    if [ -n "$CLOUD_NAME" ] && [ "$CLOUD_NAME" != "" ]; then
        echo "   ‚úÖ Cloudinary configurado - listo para producci√≥n"
    else
        echo "   üîß Configurar credenciales de Cloudinary para producci√≥n"
        echo "   üìù Variables requeridas: CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET"
    fi
else
    echo "   üîß Configurar Cloudinary para persistencia en producci√≥n"
    echo "   üìù Sin Cloudinary, las im√°genes se perder√°n en Render"
fi

echo "   üìä Monitorear regularmente la persistencia de datos"
echo "   üß™ Ejecutar estas pruebas antes de cada deployment"

echo ""

# Limpiar archivos de prueba
echo "üßπ Limpiando archivos temporales..."
rm -rf $TEST_DIR

echo ""
echo "üìÅ Log completo guardado en: $TEST_RESULTS_FILE"
echo "üèÅ Pruebas completadas - $(date)"

# Exit code basado en resultados
if [ $FINAL_COUNT -eq $TOTAL_EXPECTED ] && [ $SUCCESS_RATE -ge 80 ]; then
    exit 0
else
    exit 1
fi
