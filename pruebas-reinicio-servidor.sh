#!/bin/bash

# Pruebas de reinicio y persistencia - Simulaci√≥n de deployment en Render
# filepath: c:\Users\flavi\OneDrive\Escritorio\LibroDeResolucionesV2\pruebas-reinicio-servidor.sh

echo "üîÑ PRUEBAS DE REINICIO Y PERSISTENCIA DEL SERVIDOR"
echo "=================================================="
echo ""

# Configuraci√≥n
BASE_URL="http://localhost:10000"
ADMIN_USER="admin"
ADMIN_PASS="admin123"
TEST_RESULTS_FILE="resultados_reinicio.log"

# Colores
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Variables de control
SERVIDOR_PID=""
DATOS_ANTES=""
DATOS_DESPUES=""

log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
log_error() { echo -e "${RED}‚ùå $1${NC}"; }
log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
log_test() { echo -e "${PURPLE}üß™ $1${NC}"; }

# Funci√≥n para obtener token
get_token() {
    curl -s -X POST "$BASE_URL/api/user/login" \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"$ADMIN_USER\",\"password\":\"$ADMIN_PASS\"}" | \
        grep -o '"token":"[^"]*' | cut -d'"' -f4
}

# Funci√≥n para verificar servidor
check_server() {
    curl -s "$BASE_URL/health" > /dev/null 2>&1
    return $?
}

# Funci√≥n para obtener todas las resoluciones
get_all_data() {
    local token=$1
    curl -s "$BASE_URL/api/books/all" -H "Authorization: Bearer $token"
}

# Funci√≥n para crear resoluci√≥n de prueba
create_test_resolution() {
    local token=$1
    local timestamp=$(date +%s)
    local res_number="RESTART-TEST-$timestamp"
    
    # Crear archivo temporal
    mkdir -p temp_restart
    echo "PRUEBA DE REINICIO - $timestamp" > "temp_restart/test-$timestamp.txt"
    
    local response=$(curl -s -X POST "$BASE_URL/api/books" \
        -H "Authorization: Bearer $token" \
        -F "NumdeResolucion=$res_number" \
        -F "Asunto=Prueba de reinicio $timestamp" \
        -F "Referencia=REF-RESTART-$timestamp" \
        -F "FechaCreacion=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")" \
        -F "files=@temp_restart/test-$timestamp.txt")
    
    rm -rf temp_restart
    echo "$res_number"
}

echo "[$(date)] INICIO PRUEBAS DE REINICIO" > $TEST_RESULTS_FILE

# ===========================================
# FASE 1: VERIFICACI√ìN INICIAL
# ===========================================
log_test "FASE 1: Verificaci√≥n inicial del sistema"

if check_server; then
    log_success "Servidor respondiendo inicialmente"
else
    log_error "Servidor no est√° ejecut√°ndose"
    echo ""
    echo "üí° Para estas pruebas, el servidor debe estar corriendo:"
    echo "   cd server && npm run dev"
    exit 1
fi

TOKEN=$(get_token)
if [ -z "$TOKEN" ]; then
    log_error "No se pudo obtener token inicial"
    exit 1
fi

log_success "Token inicial obtenido"

# Obtener estado inicial
DATOS_INICIALES=$(get_all_data "$TOKEN")
COUNT_INICIAL=$(echo "$DATOS_INICIALES" | jq '. | length' 2>/dev/null || echo "0")

log_info "Resoluciones en sistema: $COUNT_INICIAL"

echo ""

# ===========================================
# FASE 2: CREAR DATOS DE PRUEBA
# ===========================================
log_test "FASE 2: Creaci√≥n de datos de prueba antes del reinicio"

log_info "Creando 3 resoluciones de prueba..."

RESOLUCIONES_CREADAS=()
for i in {1..3}; do
    res_created=$(create_test_resolution "$TOKEN")
    if [ -n "$res_created" ]; then
        RESOLUCIONES_CREADAS+=("$res_created")
        log_success "Resoluci√≥n $i creada: $res_created"
    else
        log_error "Error creando resoluci√≥n $i"
    fi
    sleep 1
done

# Verificar que se crearon
sleep 2
DATOS_ANTES_REINICIO=$(get_all_data "$TOKEN")
COUNT_ANTES=$(echo "$DATOS_ANTES_REINICIO" | jq '. | length' 2>/dev/null || echo "0")

log_info "Total de resoluciones antes del reinicio: $COUNT_ANTES"
log_info "Incremento esperado: ${#RESOLUCIONES_CREADAS[@]}"

if [ $COUNT_ANTES -eq $((COUNT_INICIAL + ${#RESOLUCIONES_CREADAS[@]})) ]; then
    log_success "Todas las resoluciones se guardaron correctamente"
else
    log_warning "Posible inconsistencia en la creaci√≥n de datos"
fi

echo ""

# ===========================================
# FASE 3: REINICIO SIMULADO DEL SERVIDOR
# ===========================================
log_test "FASE 3: Simulaci√≥n de reinicio del servidor"

log_warning "‚ö†Ô∏è  IMPORTANTE: Esta prueba simular√° un reinicio del servidor"
log_info "El servidor se detendr√° y reiniciar√° autom√°ticamente"
echo ""

# Guardar datos antes del reinicio
echo "$DATOS_ANTES_REINICIO" > "datos_antes_reinicio.json"
log_info "Datos guardados para comparaci√≥n"

# Buscar proceso del servidor
log_info "Buscando proceso del servidor Node.js..."

# En Windows, buscar procesos node
if command -v tasklist > /dev/null 2>&1; then
    NODE_PROCESSES=$(tasklist /FI "IMAGENAME eq node.exe" /FO CSV | grep -v "INFO:" | wc -l)
    log_info "Procesos Node.js encontrados: $NODE_PROCESSES"
fi

log_warning "INICIANDO REINICIO EN 3 SEGUNDOS..."
sleep 1
log_warning "REINICIO EN 2 SEGUNDOS..."
sleep 1
log_warning "REINICIO EN 1 SEGUNDO..."
sleep 1

# Detener servidor (simulaci√≥n)
log_error "üîÑ DETENIENDO SERVIDOR..."

# En Windows, buscar y detener proceso en puerto 10000
if command -v netstat > /dev/null 2>&1; then
    PORT_PID=$(netstat -ano | grep ":10000" | awk '{print $5}' | head -1)
    if [ -n "$PORT_PID" ]; then
        log_info "Proceso encontrado en puerto 10000: PID $PORT_PID"
        
        # Detener proceso
        if command -v taskkill > /dev/null 2>&1; then
            taskkill //PID $PORT_PID //F > /dev/null 2>&1
            log_warning "Servidor detenido (PID $PORT_PID)"
        fi
    fi
fi

# Esperar que el servidor se detenga
log_info "Esperando que el servidor se detenga..."
sleep 3

# Verificar que est√° detenido
if check_server; then
    log_warning "Servidor a√∫n responde - puede estar en modo autom√°tico"
else
    log_success "Servidor detenido exitosamente"
fi

echo ""

# ===========================================
# FASE 4: ESPERAR REINICIO AUTOM√ÅTICO
# ===========================================
log_test "FASE 4: Esperando reinicio autom√°tico del servidor"

log_info "Si est√° usando nodemon, el servidor deber√≠a reiniciar autom√°ticamente..."
log_info "Esperando hasta 30 segundos para que el servidor reinicie..."

# Esperar hasta 30 segundos para que el servidor reinicie
for i in {1..30}; do
    if check_server; then
        log_success "¬°Servidor reiniciado despu√©s de $i segundos!"
        break
    else
        if [ $((i % 5)) -eq 0 ]; then
            log_info "Esperando reinicio... ($i/30 segundos)"
        fi
        sleep 1
    fi
done

# Verificar si el servidor est√° de vuelta
if check_server; then
    log_success "Servidor est√° funcionando despu√©s del reinicio"
else
    log_error "Servidor no reinici√≥ autom√°ticamente"
    echo ""
    echo "üîß INSTRUCCIONES PARA CONTINUAR:"
    echo "1. Inicia manualmente el servidor: cd server && npm run dev"
    echo "2. Cuando est√© funcionando, presiona ENTER para continuar"
    read -p "Presiona ENTER cuando el servidor est√© funcionando..."
    
    # Verificar nuevamente
    if check_server; then
        log_success "Servidor manual confirmado funcionando"
    else
        log_error "Servidor a√∫n no responde - abortando pruebas"
        exit 1
    fi
fi

echo ""

# ===========================================
# FASE 5: VERIFICACI√ìN POST-REINICIO
# ===========================================
log_test "FASE 5: Verificaci√≥n de datos despu√©s del reinicio"

# Obtener nuevo token (nueva sesi√≥n)
log_info "Obteniendo nuevo token de autenticaci√≥n..."
NEW_TOKEN=$(get_token)

if [ -z "$NEW_TOKEN" ]; then
    log_error "No se pudo obtener token despu√©s del reinicio"
    log_warning "Posible problema de autenticaci√≥n o base de datos"
else
    log_success "Nuevo token obtenido despu√©s del reinicio"
fi

# Obtener datos despu√©s del reinicio
log_info "Recuperando datos despu√©s del reinicio..."
DATOS_DESPUES_REINICIO=$(get_all_data "$NEW_TOKEN")
COUNT_DESPUES=$(echo "$DATOS_DESPUES_REINICIO" | jq '. | length' 2>/dev/null || echo "0")

log_info "Resoluciones despu√©s del reinicio: $COUNT_DESPUES"
log_info "Resoluciones antes del reinicio: $COUNT_ANTES"

# Guardar datos despu√©s para comparaci√≥n
echo "$DATOS_DESPUES_REINICIO" > "datos_despues_reinicio.json"

echo ""

# ===========================================
# FASE 6: AN√ÅLISIS DE PERSISTENCIA
# ===========================================
log_test "FASE 6: An√°lisis de persistencia de datos"

# Comparar conteos
if [ $COUNT_DESPUES -eq $COUNT_ANTES ]; then
    log_success "PERSISTENCIA EXITOSA: Mismo n√∫mero de resoluciones ($COUNT_DESPUES)"
elif [ $COUNT_DESPUES -gt $COUNT_ANTES ]; then
    diff=$((COUNT_DESPUES - COUNT_ANTES))
    log_warning "Datos adicionales encontrados: +$diff resoluciones"
    log_info "Posibles duplicados o datos de sesiones anteriores"
elif [ $COUNT_DESPUES -lt $COUNT_ANTES ]; then
    diff=$((COUNT_ANTES - COUNT_DESPUES))
    log_error "P√âRDIDA DE DATOS: -$diff resoluciones perdidas"
    log_error "Problema de persistencia detectado"
fi

# Verificar resoluciones espec√≠ficas creadas
log_info "Verificando resoluciones espec√≠ficas creadas en esta sesi√≥n..."

FOUND_RESOLUTIONS=0
for resolution in "${RESOLUCIONES_CREADAS[@]}"; do
    if echo "$DATOS_DESPUES_REINICIO" | grep -q "$resolution"; then
        log_success "Resoluci√≥n encontrada: $resolution"
        ((FOUND_RESOLUTIONS++))
    else
        log_error "Resoluci√≥n PERDIDA: $resolution"
    fi
done

log_info "Resoluciones encontradas: $FOUND_RESOLUTIONS/${#RESOLUCIONES_CREADAS[@]}"

echo ""

# ===========================================
# FASE 7: VERIFICACI√ìN DE IM√ÅGENES
# ===========================================
log_test "FASE 7: Verificaci√≥n de persistencia de im√°genes"

if [ $FOUND_RESOLUTIONS -gt 0 ]; then
    log_info "Verificando im√°genes de las resoluciones encontradas..."
    
    IMAGES_FOUND=0
    IMAGES_CLOUDINARY=0
    IMAGES_LOCAL=0
    
    for resolution in "${RESOLUCIONES_CREADAS[@]}"; do
        if echo "$DATOS_DESPUES_REINICIO" | grep -q "$resolution"; then
            # Obtener detalles de la resoluci√≥n
            resolution_detail=$(curl -s "$BASE_URL/api/books/$resolution" -H "Authorization: Bearer $NEW_TOKEN")
            
            # Contar im√°genes
            images=$(echo "$resolution_detail" | jq -r '.[0].images[]' 2>/dev/null)
            
            if [ -n "$images" ]; then
                echo "$images" | while read -r image_url; do
                    if [ -n "$image_url" ]; then
                        ((IMAGES_FOUND++))
                        
                        if echo "$image_url" | grep -q "cloudinary.com"; then
                            ((IMAGES_CLOUDINARY++))
                            log_success "Imagen en Cloudinary: $image_url"
                        elif echo "$image_url" | grep -q "uploads"; then
                            ((IMAGES_LOCAL++))
                            log_warning "Imagen local: $image_url"
                        fi
                    fi
                done
            fi
        fi
    done
    
    log_info "Total de im√°genes encontradas: $IMAGES_FOUND"
    log_info "Im√°genes en Cloudinary: $IMAGES_CLOUDINARY"
    log_info "Im√°genes locales: $IMAGES_LOCAL"
    
    if [ $IMAGES_CLOUDINARY -gt 0 ]; then
        log_success "Im√°genes en Cloudinary - persistir√°n en producci√≥n"
    elif [ $IMAGES_LOCAL -gt 0 ]; then
        log_warning "Im√°genes locales - se perder√°n en Render"
    fi
else
    log_warning "No hay resoluciones para verificar im√°genes"
fi

echo ""

# ===========================================
# REPORTE FINAL
# ===========================================
echo "üìä REPORTE FINAL - PRUEBAS DE REINICIO"
echo "======================================"
echo ""

# Determinar resultado general
RESULTADO_GENERAL="DESCONOCIDO"
COLOR_RESULTADO=$YELLOW

if [ $COUNT_DESPUES -eq $COUNT_ANTES ] && [ $FOUND_RESOLUTIONS -eq ${#RESOLUCIONES_CREADAS[@]} ]; then
    RESULTADO_GENERAL="EXITOSO ‚úÖ"
    COLOR_RESULTADO=$GREEN
elif [ $COUNT_DESPUES -ge $COUNT_ANTES ] && [ $FOUND_RESOLUTIONS -gt 0 ]; then
    RESULTADO_GENERAL="PARCIALMENTE EXITOSO ‚ö†Ô∏è"
    COLOR_RESULTADO=$YELLOW
else
    RESULTADO_GENERAL="FALLIDO ‚ùå"
    COLOR_RESULTADO=$RED
fi

echo -e "${COLOR_RESULTADO}üéØ RESULTADO GENERAL: $RESULTADO_GENERAL${NC}"
echo ""

echo -e "${BLUE}üìà ESTAD√çSTICAS DE PERSISTENCIA:${NC}"
echo "   ‚Ä¢ Resoluciones antes del reinicio: $COUNT_ANTES"
echo "   ‚Ä¢ Resoluciones despu√©s del reinicio: $COUNT_DESPUES"
echo "   ‚Ä¢ Resoluciones creadas en sesi√≥n: ${#RESOLUCIONES_CREADAS[@]}"
echo "   ‚Ä¢ Resoluciones encontradas: $FOUND_RESOLUTIONS"
echo "   ‚Ä¢ Tasa de persistencia: $((FOUND_RESOLUTIONS * 100 / ${#RESOLUCIONES_CREADAS[@]} ))%"
echo ""

echo -e "${BLUE}üñºÔ∏è  AN√ÅLISIS DE IM√ÅGENES:${NC}"
if [ -f "server/.env" ] && grep -q "CLOUDINARY_CLOUD_NAME=" server/.env; then
    CLOUD_NAME=$(grep "CLOUDINARY_CLOUD_NAME=" server/.env | cut -d'=' -f2)
    if [ -n "$CLOUD_NAME" ] && [ "$CLOUD_NAME" != "" ]; then
        echo "   ‚úÖ Cloudinary configurado (persistente)"
        echo "   üåê Las im√°genes sobrevivir√°n a reinicios en producci√≥n"
    else
        echo "   ‚ö†Ô∏è  Cloudinary no configurado (no persistente)"
        echo "   üîß Configurar para producci√≥n en Render"
    fi
else
    echo "   ‚ùå Sin configuraci√≥n de Cloudinary"
    echo "   ‚ö†Ô∏è  Las im√°genes se perder√°n en Render"
fi

echo ""

echo -e "${BLUE}üìã CONCLUSIONES:${NC}"

if [ "$RESULTADO_GENERAL" = "EXITOSO ‚úÖ" ]; then
    echo "   üèÜ El sistema mantiene la persistencia correctamente"
    echo "   üèÜ Los datos sobreviven a reinicios del servidor"
    echo "   üèÜ Base de datos funcionando correctamente"
    
    if grep -q "cloudinary.com" datos_despues_reinicio.json 2>/dev/null; then
        echo "   üå©Ô∏è  Cloudinary detectado - listo para producci√≥n"
    else
        echo "   ‚ö†Ô∏è  Configurar Cloudinary para producci√≥n completa"
    fi
    
elif [ "$RESULTADO_GENERAL" = "PARCIALMENTE EXITOSO ‚ö†Ô∏è" ]; then
    echo "   ‚úÖ Persistencia b√°sica funcionando"
    echo "   ‚ö†Ô∏è  Algunas inconsistencias menores detectadas"
    echo "   üîß Revisar configuraci√≥n antes de producci√≥n"
    
else
    echo "   ‚ùå Problemas serios de persistencia"
    echo "   ‚ùå Los datos no sobreviven a reinicios"
    echo "   üö® Requiere atenci√≥n inmediata"
fi

echo ""

echo -e "${BLUE}üöÄ RECOMENDACIONES PARA PRODUCCI√ìN:${NC}"
echo "   1. Verificar que PostgreSQL est√© configurado correctamente"
echo "   2. Configurar Cloudinary para persistencia de im√°genes"
echo "   3. Probar deployment en Render con datos de prueba"
echo "   4. Monitorear logs despu√©s de cada redeploy"

echo ""

# Limpiar archivos temporales
rm -f datos_antes_reinicio.json datos_despues_reinicio.json temp_restart/* 2>/dev/null
rmdir temp_restart 2>/dev/null

echo "üìÅ Log detallado guardado en: $TEST_RESULTS_FILE"
echo "üèÅ Pruebas de reinicio completadas - $(date)"

# Exit code basado en resultado
if [ "$RESULTADO_GENERAL" = "EXITOSO ‚úÖ" ]; then
    exit 0
elif [ "$RESULTADO_GENERAL" = "PARCIALMENTE EXITOSO ‚ö†Ô∏è" ]; then
    exit 1
else
    exit 2
fi
